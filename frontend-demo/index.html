<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Dynamic-Knowledge-Graph-Demo</title>
    <link rel="stylesheet" href="style.css"/>
  </head>
  <body>
    <div id="header">
      <h2>Dynamic-Knowledge-Graph-Demo</h2>
      <button id="gearButton" title="Settings">⚙️</button>
    </div>

    <div id="apiPrompt">
      <label for="apiKey">Enter OpenAI API Key:</label>
      <div class="inputRow">
        <input type="password" id="apiKey" placeholder="sk-..." />
        <button id="setApiKey">Save</button>
      </div>
    </div>

    <div id="chatContainer"></div>

    <div id="inputArea">
      <div class="inputWrapper">
        <textarea id="userInput" rows="1" placeholder="Type a message..."></textarea>
        <button id="runButton" title="Send">➤</button>
      </div>
    </div>

    <script type="module">
      import {
        runStreamingFlow,
        formatToolCallsMarkdown
      } from './script.js?cachebust=8';

      import { marked } from 'https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js';

      const userInputField = document.getElementById('userInput');
      const runButton = document.getElementById('runButton');
      const chatContainer = document.getElementById('chatContainer');
      const apiPrompt = document.getElementById('apiPrompt');
      const apiKeyInput = document.getElementById('apiKey');
      const setApiKeyBtn = document.getElementById('setApiKey');
      const gearButton = document.getElementById('gearButton');

      // API key gate
      const storedKey = localStorage.getItem('OPENAI_API_KEY');
      apiPrompt.style.display = storedKey && storedKey.startsWith('sk-') ? 'none' : 'block';

      setApiKeyBtn.addEventListener('click', () => {
        const key = apiKeyInput.value.trim();
        if (!key.startsWith('sk-')) { alert('Invalid key format'); return; }
        localStorage.setItem('OPENAI_API_KEY', key);
        apiPrompt.style.display = 'none';
      });

      gearButton.addEventListener('click', () => {
        apiPrompt.style.display = apiPrompt.style.display === 'block' ? 'none' : 'block';
      });

      // Helpers
      function appendMessageBubble({ html = '', text = '', cls = '' }) {
        const div = document.createElement('div');
        div.className = `message ${cls}`.trim();
        if (html) div.innerHTML = html; else div.textContent = text;
        chatContainer.appendChild(div);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return div;
      }

      function createExpandableThoughtsBubble() {
        const container = document.createElement('div');
        container.className = 'message bot expandable';

        const header = document.createElement('div');
        header.className = 'expander-header';
        const caret = document.createElement('span');
        caret.className = 'caret';
        caret.textContent = '▸';
        const title = document.createElement('span');
        title.textContent = 'Thoughts (click to expand)';
        const live = document.createElement('span');
        live.className = 'live-dot';
        header.append(caret, title, live);

        const body = document.createElement('div');
        body.className = 'expander-body';

        // Sections
        const s1 = document.createElement('div');
        s1.className = 'section';
        s1.innerHTML = `<h4>Initial Reasoning</h4><div class="md" data-id="p1"></div>`;

        const s15 = document.createElement('div');
        s15.className = 'section';
        s15.innerHTML = `<h4>Graph Connecting Phase</h4><div class="md" data-id="p15"></div>`;

        const sTools = document.createElement('div');
        sTools.className = 'section';
        sTools.innerHTML = `<h4>Tool Calls</h4><div class="md" data-id="tools" class="mono dim"></div>`;

        body.append(s1, s15, sTools);
        container.append(header, body);
        chatContainer.appendChild(container);
        chatContainer.scrollTop = chatContainer.scrollHeight;

        // Toggle
        let expanded = false;
        header.addEventListener('click', () => {
          expanded = !expanded;
          container.classList.toggle('expanded', expanded);
          caret.textContent = expanded ? '▾' : '▸';
          title.textContent = expanded ? 'Thoughts (expanded)' : 'Thoughts (click to expand)';
        });

        return {
          container,
          header,
          body,
          setLive(visible) { live.style.display = visible ? 'inline-block' : 'none'; },
          setExpandedNow() { // open immediately if user clicks mid-run
            if (!container.classList.contains('expanded')) {
              container.classList.add('expanded');
              caret.textContent = '▾';
              title.textContent = 'Thoughts (expanded)';
            }
          },
          elP1() { return body.querySelector('[data-id="p1"]'); },
          elP15() { return body.querySelector('[data-id="p15"]'); },
          elTools() { return body.querySelector('[data-id="tools"]'); },
        };
      }

      // Streaming final bubble updates w/ markdown
      function createStreamingBotBubble() {
        const div = appendMessageBubble({ html: `<div class="md dim">Generating…<span class="live-dot"></span></div>`, cls: 'bot' });
        return {
          update(markdown) {
            div.querySelector('.md').innerHTML = marked.parse(markdown || '');
            chatContainer.scrollTop = chatContainer.scrollHeight;
          },
          done() {
            const md = div.querySelector('.md');
            if (md) md.classList.remove('dim');
            const live = div.querySelector('.live-dot');
            if (live) live.remove();
          }
        };
      }

      function throttle(fn, ms) {
        let t = 0, lastArgs = null, scheduled = false;
        return (...args) => {
          lastArgs = args;
          const now = performance.now();
          const doRun = () => { scheduled = false; t = performance.now(); fn(...lastArgs); };
          if (!scheduled && now - t >= ms) doRun();
          else if (!scheduled) { scheduled = true; setTimeout(doRun, ms - (now - t)); }
        };
      }

      async function sendMessage() {
        const input = userInputField.value.trim();
        if (!input) return;

        // User bubble
        appendMessageBubble({ html: marked.parse(input), cls: 'user' });
        userInputField.value = '';
        autoResize();

        // Thoughts bubble (expandable, clickable immediately)
        const thoughts = createExpandableThoughtsBubble();

        // Final answer bubble (streams)
        const finalBubble = createStreamingBotBubble();

        let p1Buf = '';
        let p15Buf = '';
        let toolsMarkdown = '';

        const renderP1 = throttle(() => {
          thoughts.elP1().innerHTML = marked.parse(p1Buf || '*…*');
        }, 80);

        const renderP15 = throttle(() => {
          thoughts.elP15().innerHTML = marked.parse(p15Buf || '*…*');
        }, 80);

        const renderTools = throttle(() => {
          thoughts.elTools().innerHTML = marked.parse(toolsMarkdown || '_No tool calls yet._');
        }, 120);

        try {
          await runStreamingFlow(input, {
            onPrompt1Delta(chunk) {
              p1Buf += chunk;
              renderP1();
            },
            onPrompt1Start() {
              thoughts.setLive(true);
            },
            async onPrompt1ToolRun(logArray) {
              toolsMarkdown = formatToolCallsMarkdown(logArray);
              renderTools();
            },
            onPrompt1Done() {
              renderP1();
            },

            onPrompt15Start() {
              thoughts.setLive(true);
            },
            onPrompt15Delta(chunk) {
              p15Buf += chunk;
              renderP15();
            },
            async onPrompt15ToolRun(logArray) {
              toolsMarkdown = formatToolCallsMarkdown(logArray);
              renderTools();
            },
            onPrompt15Done() {
              renderP15();
            },

            onFinalStart() {
              thoughts.setLive(false);
            },
            onFinalDelta(chunk, fullSoFar) {
              finalBubble.update(fullSoFar);
            },
            onFinalDone() {
              finalBubble.done();
            }
          });

        } catch (err) {
          finalBubble.update(`**Error:** ${err.message}`);
          finalBubble.done();
        }
      }

      runButton.addEventListener('click', sendMessage);
      userInputField.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      });

      function autoResize() {
        userInputField.style.height = 'auto';
        userInputField.style.height = userInputField.scrollHeight + 'px';
      }
      userInputField.addEventListener('input', autoResize);
    </script>
  </body>
</html>
