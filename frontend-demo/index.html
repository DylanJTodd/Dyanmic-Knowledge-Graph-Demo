<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic-Knowledge-Graph-Demo</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>

    <!-- Header -->
    <div id="header">
      <div id="viewSwitcher">
        <button id="chatViewBtn" class="active">Chat</button>
        <button id="graphViewBtn">Graph</button>
      </div>
      <h2>Dynamic-Knowledge-Graph-Demo</h2>
      <button id="gearButton" title="Settings">‚öôÔ∏è</button>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel">
      <div class="settings-group">
        <label for="apiKey">OpenAI API Key:</label>
        <div class="inputRow">
          <input type="password" id="apiKey" placeholder="sk-..." />
          <button id="setApiKey">Save</button>
        </div>
      </div>
      <div class="settings-group">
        <h4>AI Settings</h4>
        <label for="temperature-slider"
          >Temperature: <span id="temperature-value">0.7</span></label
        >
        <input
          type="range"
          id="temperature-slider"
          min="0"
          max="2"
          step="0.1"
          value="0.7"
        />
        <label for="max-tokens-slider"
          >Max Tokens: <span id="max-tokens-value">4096</span></label
        >
        <input
          type="range"
          id="max-tokens-slider"
          min="512"
          max="8192"
          step="256"
          value="4096"
        />
      </div>
    </div>

    <!-- Chat Area -->
    <div id="chatView">
      <div id="chatContainer"></div>
      <div id="inputArea">
        <small class="api-cost-notice">Note: Each message uses the OpenAI API and may incur costs.</small>
        <div class="inputWrapper">
          <textarea
            id="userInput"
            rows="1"
            placeholder="Type a message..."
          ></textarea>
          <button id="runButton" title="Send">‚û§</button>
        </div>
      </div>
    </div>

    <!-- Graph Area -->
    <div id="graphView">
      <div id="personality-archetype"></div>
      <div id="turn-summary"></div>
      <div id="cy"></div>
      <div id="graph-controls">
        <button id="home-btn" title="Center Graph">‚åÇ</button>
        <button id="save-graph-btn" title="Save Graph">üíæ</button>
        <button id="load-graph-btn" title="Load Graph">üìÇ</button>
        <button id="filter-btn" title="Filter Nodes">üîç</button>
        <button id="add-node-btn">+ Add Node</button>
        <button id="cancel-edge-btn" style="display: none">Cancel Edge</button>
      </div>
      <input type="file" id="load-graph-input" accept=".json,application/json" style="display: none;">
      
      <div id="filter-panel" style="display: none;">
        <input type="text" id="filter-label-input" placeholder="Search label...">
        <select id="filter-type-select">
          <option value="">All Types</option>
        </select>
        <input type="number" id="filter-connections-input" placeholder="Min connections" min="0">
        <button id="apply-filter-btn">Apply</button>
        <button id="clear-filter-btn">Clear</button>
      </div>
      <div id="info-panel" class="info-panel" style="display: none">
        <button id="info-panel-close" class="info-panel__close">&times;</button>
        <div id="info-panel-content"></div>
        <div id="info-panel-actions"></div>
      </div>
      <div id="graph-legend">
        <div class="legend-item"><span class="legend-color gold"></span> Changed this turn</div>
        <div class="legend-item"><span class="legend-color blue"></span> Selected & connected</div>
      </div>
    </div>

    <!-- Input Modal -->
    <div id="input-modal-overlay" style="display: none">
      <div id="input-modal">
        <h3 id="modal-title"></h3>
        <div id="modal-body"></div>
        <div id="modal-actions">
          <button id="modal-cancel-btn">Cancel</button>
          <button id="modal-save-btn">Save</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script type="module">
      // --- MODIFIED IMPORTS ---
      import { runStreamingFlow, generateSummaries, formatToolCallsMarkdown, resetChatHistory } from "./script.js?cachebust=18";
      import { exportGraphJson, clearGraph, loadGraphFromJSON } from "./user_tools.js?cachebust=18";
      import { initGraphVisualization, renderGraph } from "./graph-view.js?cachebust=18";
      import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";

      const chatView = document.getElementById("chatView");
      const graphView = document.getElementById("graphView");
      const chatViewBtn = document.getElementById("chatViewBtn");
      const graphViewBtn = document.getElementById("graphViewBtn");
      const gearButton = document.getElementById("gearButton");
      const settingsPanel = document.getElementById("settingsPanel");
      const apiKeyInput = document.getElementById("apiKey");
      const setApiKeyBtn = document.getElementById("setApiKey");
      const temperatureSlider = document.getElementById("temperature-slider");
      const temperatureValueSpan = document.getElementById("temperature-value");
      const maxTokensSlider = document.getElementById("max-tokens-slider");
      const maxTokensValueSpan = document.getElementById("max-tokens-value");
      const userInputField = document.getElementById("userInput");
      const runButton = document.getElementById("runButton");
      const chatContainer = document.getElementById("chatContainer");
      const graphControlsButtons = document.querySelectorAll("#graph-controls button");

      let isBotResponding = false;

      //Reset state
      window.addEventListener("load", () => {
        clearGraph();
        sessionStorage.removeItem("KNOWLEDGE_GRAPH_STATE");
        sessionStorage.removeItem("GRAPH_DIFF");
        sessionStorage.removeItem("PERSONALITY_ARCHETYPE");
        sessionStorage.removeItem("TURN_SUMMARY");
        loadSettings();
        updateGraphViewButtonState();
      });

      function isGraphEmpty() {
        const graphJSON = sessionStorage.getItem('KNOWLEDGE_GRAPH_STATE');
        if (!graphJSON) return true;
        try {
          const graph = JSON.parse(graphJSON);
          return !graph.nodes || graph.nodes.length === 0;
        } catch {
          return true;
        }
      }

      function updateGraphViewButtonState() {
          graphViewBtn.disabled = isBotResponding || isGraphEmpty();
      }

      function setGraphControlsEnabled(enabled) {
          graphControlsButtons.forEach(btn => btn.disabled = !enabled);
      }

      function loadSettings() {
        const storedKey = localStorage.getItem("OPENAI_API_KEY");
        if (storedKey) apiKeyInput.value = storedKey;
        settingsPanel.style.display = !storedKey || !storedKey.startsWith("sk-") ? "block" : "none";

        const aiSettings = JSON.parse(localStorage.getItem("AI_SETTINGS")) || {};
        const temp = aiSettings.temperature !== undefined ? aiSettings.temperature : 0.7;
        temperatureSlider.value = temp;
        temperatureValueSpan.textContent = temp;
        const tokens = aiSettings.max_tokens !== undefined ? aiSettings.max_tokens : 4096;
        maxTokensSlider.value = tokens;
        maxTokensValueSpan.textContent = tokens;
      }

      function saveAiSettings() {
        localStorage.setItem(
          "AI_SETTINGS",
          JSON.stringify({
            temperature: parseFloat(temperatureSlider.value),
            max_tokens: parseInt(maxTokensSlider.value, 10),
          })
        );
      }

      setApiKeyBtn.addEventListener("click", () => {
        const key = apiKeyInput.value.trim();
        if (!key.startsWith("sk-")) {
          alert("Invalid key format");
          return;
        }
        localStorage.setItem("OPENAI_API_KEY", key);
        settingsPanel.style.display = "none";

        if (graphView.style.display === "flex") {
            setGraphControlsEnabled(true);
        }
      });

      gearButton.addEventListener("click", () => {
        const isOpening = settingsPanel.style.display !== "block";
        settingsPanel.style.display = isOpening ? "block" : "none";
        
        if (graphView.style.display === "flex") {
            setGraphControlsEnabled(!isOpening);
        }
      });

      temperatureSlider.addEventListener("input", () => {
        temperatureValueSpan.textContent = temperatureSlider.value;
        saveAiSettings();
      });
      maxTokensSlider.addEventListener("input", () => {
        maxTokensValueSpan.textContent = maxTokensSlider.value;
        saveAiSettings();
      });

      let graphInitialized = false;
      chatViewBtn.addEventListener("click", () => {
        chatView.style.display = "flex";
        graphView.style.display = "none";
        chatViewBtn.classList.add("active");
        graphViewBtn.classList.remove("active");
        setGraphControlsEnabled(true);
      });
      graphViewBtn.addEventListener("click", () => {
        if (isBotResponding) {
          alert("Please wait for the current response to complete before switching views.");
          return;
        }
        if (isGraphEmpty()) {
          alert("The knowledge graph is empty. Send a message to start building it.");
          return;
        }
        chatView.style.display = "none";
        graphView.style.display = "flex";
        chatViewBtn.classList.remove("active");
        graphViewBtn.classList.add("active");
        if (!graphInitialized) {
          initGraphVisualization("cy");
          graphInitialized = true;
        }
        renderGraph();
        
        const settingsAreOpen = settingsPanel.style.display === 'block';
        setGraphControlsEnabled(!settingsAreOpen);
      });

      // --- ADDED: Event listener for loading a graph file ---
      window.addEventListener('graph-loaded', (e) => {
          const newGraphJSON = e.detail; // This is now the JSON string from the file
          if (!newGraphJSON) return;

          if (!confirm("Loading a new graph will clear the current session, including chat history and the current graph. Are you sure?")) {
              return;
          }

          // 1. Reset application state
          isBotResponding = false;
          runButton.disabled = false;
          chatContainer.innerHTML = '';
          resetChatHistory();
          clearGraph();
          sessionStorage.removeItem("KNOWLEDGE_GRAPH_STATE");
          sessionStorage.removeItem("GRAPH_DIFF");
          sessionStorage.removeItem("PERSONALITY_ARCHETYPE");
          sessionStorage.removeItem("TURN_SUMMARY");

          // 2. Load new graph state
          sessionStorage.setItem('KNOWLEDGE_GRAPH_STATE', newGraphJSON);
          loadGraphFromJSON(newGraphJSON); 

          // 3. Update UI
          if (graphView.style.display !== "flex") {
              graphViewBtn.click();
          } else {
              renderGraph();
          }
          updateGraphViewButtonState();
          alert("Graph loaded successfully.");
      });

      function createExpandableThoughtsBubble() {
        const container = document.createElement("div");
        container.className = "message bot expandable";
        const header = document.createElement("div");
        header.className = "expander-header";
        const caret = document.createElement("span");
        caret.className = "caret";
        caret.textContent = "‚ñ∏";
        const title = document.createElement("span");
        title.textContent = "Internal Monologue & Tool Log";
        const live = document.createElement("span");
        live.className = "live-dot";
        header.append(caret, title, live);
        const body = document.createElement("div");
        body.className = "expander-body";
        body.innerHTML = `
          <div class="section"><h4>Phase 1: Initial Reflection</h4><div class="md" data-id="p1"></div></div>
          <div class="section"><h4>Phase 1.5: Introspection</h4><div class="md" data-id="p15"></div></div>
          <div class="section"><h4>Tool Calls</h4><div class="md" data-id="tools" class="mono dim"></div></div>
        `;
        container.append(header, body);
        chatContainer.appendChild(container);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        let expanded = false;
        header.addEventListener("click", () => {
          expanded = !expanded;
          container.classList.toggle("expanded", expanded);
          caret.textContent = expanded ? "‚ñæ" : "‚ñ∏";
        });
        return {
          setLive(visible) { live.style.display = visible ? "inline-block" : "none"; },
          updateTitle(newText) { title.textContent = newText; },
          elP1() { return body.querySelector('[data-id="p1"]'); },
          elP15() { return body.querySelector('[data-id="p15"]'); },
          elTools() { return body.querySelector('[data-id="tools"]'); },
        };
      }

      function throttle(fn, ms) {
        let t = 0, lastArgs = null, scheduled = false;
        return (...args) => {
          lastArgs = args;
          const now = performance.now();
          const doRun = () => { scheduled = false; t = performance.now(); fn(...lastArgs); };
          if (!scheduled && now - t >= ms) doRun();
          else if (!scheduled) { scheduled = true; setTimeout(doRun, ms - (now - t)); }
        };
      }

      async function sendMessage() {
        const input = userInputField.value.trim();
        if (!input || isBotResponding) return;

        isBotResponding = true;
        runButton.disabled = true;
        updateGraphViewButtonState();

        appendMessageBubble({ html: marked.parse(input), cls: "user" });
        userInputField.value = "";
        autoResize();

        const thoughts = createExpandableThoughtsBubble();
        const finalBubble = createStreamingBotBubble();
        
        let p1Buf = "", p15Buf = "";
        const renderP1 = throttle(() => thoughts.elP1().innerHTML = marked.parse(p1Buf || "*‚Ä¶*"), 80);
        const renderP15 = throttle(() => thoughts.elP15().innerHTML = marked.parse(p15Buf || "*‚Ä¶*"), 80);
        const renderTools = throttle((log) => thoughts.elTools().innerHTML = marked.parse(formatToolCallsMarkdown(log) || "_No tool calls yet._"), 120);
        
        const startTime = performance.now();
        let timerInterval = null;

        try {
          const finalContent = await runStreamingFlow(input, {
            onPrompt1Start: () => {
              thoughts.setLive(true);
              timerInterval = setInterval(() => {
                  const duration = ((performance.now() - startTime) / 1000).toFixed(1);
                  thoughts.updateTitle(`Thinking for ${duration}s...`);
              }, 100);
            },
            onPrompt1Delta: (chunk) => { p1Buf += chunk; renderP1(); },
            onPrompt1ToolRun: (log) => { renderTools(log); sessionStorage.setItem("KNOWLEDGE_GRAPH_STATE", exportGraphJson()); },
            onPrompt1Done: () => renderP1(),
            onPrompt15Start: () => thoughts.setLive(true),
            onPrompt15Delta: (chunk) => { p15Buf += chunk; renderP15(); },
            onPrompt15ToolRun: (log) => { renderTools(log); sessionStorage.setItem("KNOWLEDGE_GRAPH_STATE", exportGraphJson()); },
            onPrompt15Done: () => renderP15(),
            onFinalStart: () => {
              clearInterval(timerInterval);
              thoughts.setLive(false);
              const endTime = performance.now();
              const duration = ((endTime - startTime) / 1000).toFixed(2);
              thoughts.updateTitle(`Internal Monologue & Tool Log (Thinking took ${duration}s)`);
            },
            onFinalDelta: (chunk, full) => finalBubble.update(full),
            onFinalDone: () => finalBubble.done(),
          });

          const graphDiff = JSON.parse(sessionStorage.getItem('GRAPH_DIFF') || '{}');
          const graphState = sessionStorage.getItem('KNOWLEDGE_GRAPH_STATE');
          const [diffSummary, personalitySummary] = await generateSummaries(input, finalContent, graphDiff, graphState);
          
          sessionStorage.setItem('TURN_SUMMARY', diffSummary || '');
          sessionStorage.setItem('PERSONALITY_ARCHETYPE', personalitySummary || '');

        } catch (err) {
          finalBubble.update(`**Error:** ${err.message}`);
          finalBubble.done();
        } finally {
            if(timerInterval) clearInterval(timerInterval);
            isBotResponding = false;
            runButton.disabled = false;
            updateGraphViewButtonState();
        }
      }

      function appendMessageBubble({ html = "", text = "", cls = "" }) {
        const div = document.createElement("div");
        div.className = `message ${cls}`.trim();
        if (html) div.innerHTML = html;
        else div.textContent = text;
        chatContainer.appendChild(div);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return div;
      }

      function createStreamingBotBubble() {
        const div = appendMessageBubble({
          html: `<div class="md dim">Generating‚Ä¶<span class="live-dot"></span></div>`,
          cls: "bot",
        });
        return {
          update(markdown) {
            div.querySelector(".md").innerHTML = marked.parse(markdown || "");
            chatContainer.scrollTop = chatContainer.scrollHeight;
          },
          done() {
            const md = div.querySelector(".md");
            if (md) md.classList.remove("dim");
            const live = div.querySelector(".live-dot");
            if (live) live.remove();
          },
        };
      }

      function autoResize() {
        userInputField.style.height = "auto";
        userInputField.style.height = userInputField.scrollHeight + "px";
      }
      userInputField.addEventListener("input", autoResize);
      runButton.addEventListener("click", sendMessage);
      userInputField.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
    </script>
  </body>
</html>